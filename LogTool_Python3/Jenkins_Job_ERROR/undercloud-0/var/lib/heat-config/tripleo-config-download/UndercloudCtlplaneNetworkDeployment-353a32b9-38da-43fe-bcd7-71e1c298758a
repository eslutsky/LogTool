[{"config": "#!/usr/libexec/platform-python\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\nimport json\nimport netaddr\nimport openstack\nimport os\nimport subprocess\n\nCTLPLANE_NETWORK_NAME = 'ctlplane'\nCONF = json.loads(os.environ['config'])\n\n\ndef _run_command(args, env=None, name=None):\n    \"\"\"Run the command defined by args and return its output\n\n    :param args: List of arguments for the command to be run.\n    :param env: Dict defining the environment variables. Pass None to use\n        the current environment.\n    :param name: User-friendly name for the command being run. A value of\n        None will cause args[0] to be used.\n    \"\"\"\n    if name is None:\n        name = args[0]\n\n    if env is None:\n        env = os.environ\n    env = env.copy()\n\n    # When running a localized python script, we need to tell it that we're\n    # using utf-8 for stdout, otherwise it can't tell because of the pipe.\n    env['PYTHONIOENCODING'] = 'utf8'\n\n    try:\n        return subprocess.check_output(args,\n                                       stderr=subprocess.STDOUT,\n                                       env=env).decode('utf-8')\n    except subprocess.CalledProcessError as ex:\n        print('ERROR: %s failed: %s' % (name, ex.output))\n        raise\n\n\ndef _ensure_neutron_network(sdk):\n    try:\n        network = list(sdk.network.networks(name=CTLPLANE_NETWORK_NAME))\n        if not network:\n            network = sdk.network.create_network(\n                name=CTLPLANE_NETWORK_NAME,\n                provider_network_type='flat',\n                provider_physical_network=CONF['physical_network'],\n                mtu=CONF['mtu'])\n            print('INFO: Network created %s' % network)\n        else:\n            network = sdk.network.update_network(\n                network[0].id,\n                name=CTLPLANE_NETWORK_NAME,\n                mtu=CONF['mtu'])\n            print('INFO: Network updated %s' % network)\n    except Exception:\n        print('ERROR: Network create/update failed.')\n        raise\n\n    return network\n\n\ndef _get_nameservers_for_version(servers, ipversion):\n    \"\"\"Get list of nameservers for an IP version\"\"\"\n    return [s for s in servers if netaddr.IPAddress(s).version == ipversion]\n\n\ndef _neutron_subnet_create(sdk, network_id, cidr, gateway, host_routes,\n                           allocation_pools, name, segment_id,\n                           dns_nameservers):\n    try:\n        if netaddr.IPNetwork(cidr).version == 6:\n            subnet = sdk.network.create_subnet(\n                name=name,\n                cidr=cidr,\n                gateway_ip=gateway,\n                enable_dhcp=True,\n                ip_version='6',\n                ipv6_address_mode=CONF['ipv6_address_mode'],\n                ipv6_ra_mode=CONF['ipv6_address_mode'],\n                allocation_pools=allocation_pools,\n                network_id=network_id,\n                segment_id=segment_id,\n                dns_nameservers=_get_nameservers_for_version(dns_nameservers,\n                                                             6))\n        else:\n            subnet = sdk.network.create_subnet(\n                name=name,\n                cidr=cidr,\n                gateway_ip=gateway,\n                host_routes=host_routes,\n                enable_dhcp=True,\n                ip_version='4',\n                allocation_pools=allocation_pools,\n                network_id=network_id,\n                segment_id=segment_id,\n                dns_nameservers=_get_nameservers_for_version(dns_nameservers,\n                                                             4))\n            print('INFO: Subnet created %s' % subnet)\n    except Exception:\n        print('ERROR: Create subnet %s failed.' % name)\n        raise\n\n    return subnet\n\n\ndef _neutron_subnet_update(sdk, subnet_id, cidr, gateway, host_routes,\n                           allocation_pools, name, dns_nameservers):\n    try:\n        if netaddr.IPNetwork(cidr).version == 6:\n            subnet = sdk.network.update_subnet(\n                subnet_id,\n                name=name,\n                gateway_ip=gateway,\n                allocation_pools=allocation_pools,\n                dns_nameservers=_get_nameservers_for_version(dns_nameservers,\n                                                             6))\n        else:\n            subnet = sdk.network.update_subnet(\n                subnet_id,\n                name=name,\n                gateway_ip=gateway,\n                host_routes=host_routes,\n                allocation_pools=allocation_pools,\n                dns_nameservers=_get_nameservers_for_version(dns_nameservers,\n                                                             4))\n        print('INFO: Subnet updated %s' % subnet)\n    except Exception:\n        print('ERROR: Update of subnet %s failed.' % name)\n        raise\n\n\ndef _neutron_add_subnet_segment_association(sdk, subnet_id, segment_id):\n    try:\n        subnet = sdk.network.update_subnet(subnet_id, segment_id=segment_id)\n        print('INFO: Segment association added to Subnet  %s' % subnet)\n    except Exception:\n        print('ERROR: Associationg segment with subnet %s failed.' % subnet_id)\n        raise\n\n\ndef _neutron_segment_create(sdk, name, network_id, phynet):\n    try:\n        segment = sdk.network.create_segment(\n            name=name,\n            network_id=network_id,\n            physical_network=phynet,\n            network_type='flat')\n        print('INFO: Neutron Segment created %s' % segment)\n    except Exception:\n        print('ERROR: Neutron Segment %s create failed.' % name)\n        raise\n\n    return segment\n\n\ndef _neutron_segment_update(sdk, segment_id, name):\n    try:\n        segment = sdk.network.update_segment(segment_id, name=name)\n        print('INFO: Neutron Segment updated %s', segment)\n    except Exception:\n        print('ERROR: Neutron Segment %s update failed.' % name)\n        raise\n\n\ndef _ensure_neutron_router(sdk, name, subnet_id):\n    # If the router already exist, don't try to create it again.\n    if list(sdk.network.routers(name=name)):\n        return\n\n    try:\n        router = sdk.network.create_router(name=name, admin_state_up='true')\n        sdk.network.add_interface_to_router(router.id, subnet_id=subnet_id)\n    except Exception:\n        print('ERROR: Create router for subnet %s failed.' % name)\n        raise\n\n\ndef _get_subnet(sdk, cidr, network_id):\n    try:\n        subnet = list(sdk.network.subnets(cidr=cidr, network_id=network_id))\n    except Exception:\n        print('ERROR: Get subnet with cidr %s failed.' % cidr)\n        raise\n\n    return False if not subnet else subnet[0]\n\n\ndef _get_segment(sdk, phy, network_id):\n    try:\n        segment = list(sdk.network.segments(physical_network=phy,\n                                            network_id=network_id))\n    except Exception:\n        print('ERROR: Get segment for physical_network %s on network_id %s '\n              'failed.' % (phy, network_id))\n        raise\n\n    return False if not segment else segment[0]\n\n\ndef _set_network_tags(sdk, network, tags):\n    try:\n        sdk.network.set_tags(network, tags=tags)\n        print('INFO: Tags %s added to network %s.' % (tags, network.name))\n    except Exception:\n        print('ERROR: Setting tags %s on network %s failed.' %\n              (tags, network.name))\n        raise\n\n\ndef _local_neutron_segments_and_subnets(sdk, ctlplane_id, net_cidrs):\n    \"\"\"Create's and updates the ctlplane subnet on the segment that is local to\n    the underclud.\n    \"\"\"\n\n    s = CONF['subnets'][CONF['local_subnet']]\n    name = CONF['local_subnet']\n    subnet = _get_subnet(sdk, s['NetworkCidr'], ctlplane_id)\n    segment = _get_segment(sdk, CONF['physical_network'], ctlplane_id)\n    if subnet:\n        if CONF['enable_routed_networks'] and subnet.segment_id is None:\n            # The subnet exists and does not have a segment association. Since\n            # routed networks is enabled in the configuration, we need to\n            # migrate the existing non-routed networks subnet to a routed\n            # networks subnet by associating the network segment_id with the\n            # subnet.\n            _neutron_add_subnet_segment_association(sdk, subnet.id, segment.id)\n        _neutron_subnet_update(\n            sdk, subnet.id, s['NetworkCidr'], s['NetworkGateway'],\n            s['HostRoutes'], s.get('AllocationPools'), name,\n            s['DnsNameServers'])\n    else:\n        if CONF['enable_routed_networks']:\n            segment_id = segment.id\n        else:\n            segment_id = None\n        subnet = _neutron_subnet_create(\n            sdk, ctlplane_id, s['NetworkCidr'], s['NetworkGateway'],\n            s['HostRoutes'], s.get('AllocationPools'), name, segment_id,\n            s['DnsNameServers'])\n        # If the subnet is IPv6 we need to start a router so that router\n        #  advertisments are sent out for stateless IP addressing to work.\n        # NOTE(hjensas): Don't do this for routed networks. The router will\n        #  use the address defined as gateway for the subnet, and in a\n        #  deployment with routed networks this will conflict with the router\n        #  in the infrastructure. The router in the infrastucture must be\n        #  configured to send router advertisements.\n        if not CONF['enable_routed_networks']:\n            if netaddr.IPNetwork(s['NetworkCidr']).version == 6:\n                _ensure_neutron_router(sdk, name, subnet.id)\n    net_cidrs.append(s['NetworkCidr'])\n\n    return net_cidrs\n\n\ndef _remote_neutron_segments_and_subnets(sdk, ctlplane_id, net_cidrs):\n    \"\"\"Create's and updates the ctlplane subnet(s) on segments that is\n    not local to the undercloud.\n    \"\"\"\n\n    for name in CONF['subnets']:\n        s = CONF['subnets'][name]\n        if name == CONF['local_subnet']:\n            continue\n        phynet = name\n        subnet = _get_subnet(sdk, s['NetworkCidr'], ctlplane_id)\n        segment = _get_segment(sdk, phynet, ctlplane_id)\n        if subnet:\n            _neutron_segment_update(sdk, subnet.segment_id, name)\n            _neutron_subnet_update(\n                sdk, subnet.id, s['NetworkCidr'], s['NetworkGateway'],\n                s['HostRoutes'], s.get('AllocationPools'), name,\n                s['DnsNameServers'])\n        else:\n            if segment:\n                _neutron_segment_update(sdk, segment.id, name)\n            else:\n                segment = _neutron_segment_create(sdk, name, ctlplane_id,\n                                                  phynet)\n            subnet = _neutron_subnet_create(\n                sdk, ctlplane_id, s['NetworkCidr'], s['NetworkGateway'],\n                s['HostRoutes'], s.get('AllocationPools'), name, segment.id,\n                s['DnsNameServers'])\n        net_cidrs.append(s['NetworkCidr'])\n\n    return net_cidrs\n\n\nif 'true' not in _run_command(['hiera', 'neutron_api_enabled'],\n                              name='hiera').lower():\n    print('WARNING: UndercloudCtlplaneNetworkDeployment : The Neutron API '\n          'is disabled. The ctlplane network cannot be configured.')\nelse:\n    sdk = openstack.connect(CONF['cloud_name'])\n\n    network = _ensure_neutron_network(sdk)\n    net_cidrs = []\n    # Always create/update the local_subnet first to ensure it is can have the\n    # subnet associated with a segment prior to creating the remote subnets if\n    # the user enabled routed networks support on undercloud update.\n    net_cidrs = _local_neutron_segments_and_subnets(sdk, network.id, net_cidrs)\n    if CONF['enable_routed_networks']:\n        net_cidrs = _remote_neutron_segments_and_subnets(sdk, network.id,\n                                                         net_cidrs)\n    # Set the cidrs for all ctlplane subnets as tags on the ctlplane network.\n    # These tags are used for the NetCidrMapValue in tripleo-heat-templates.\n    _set_network_tags(sdk, network, net_cidrs)\n", "creation_time": "2020-03-04T03:03:08Z", "deployment_name": "UndercloudCtlplaneNetworkDeployment", "group": "script", "id": "353a32b9-38da-43fe-bcd7-71e1c298758a", "inputs": [{"name": "config", "description": null, "type": "String", "value": "{\"cloud_name\": \"undercloud\", \"enable_routed_networks\": false, \"home_dir\": \"/home/stack\", \"ipv6_address_mode\": \"dhcpv6-stateless\", \"local_ip\": \"192.168.24.3\", \"local_subnet\": \"ctlplane-subnet\", \"mtu\": 1500, \"physical_network\": \"ctlplane\", \"subnets\": {\"ctlplane-subnet\": {\"AllocationPools\": [{\"end\": \"192.168.24.55\", \"start\": \"192.168.24.5\"}], \"DnsNameServers\": [\"172.16.0.1\", \"10.0.0.1\"], \"HostRoutes\": [], \"NetworkCidr\": \"192.168.24.0/24\", \"NetworkGateway\": \"192.168.24.1\"}}}"}, {"name": "deploy_server_id", "description": "ID of the server being deployed to", "type": "String", "value": "1e6ea2e1-c44d-4e40-b09e-10d94ca508c0"}, {"name": "deploy_action", "description": "Name of the current action being deployed", "type": "String", "value": "CREATE"}, {"name": "deploy_stack_id", "description": "ID of the stack this deployment belongs to", "type": "String", "value": "undercloud-AllNodesDeploySteps-zuuy36jjpozg-UndercloudExtraConfigPost-chemsis6sbys-UndercloudCtlplaneNetworkDeployment-e2he5ztctzeg-0-hqwwaxammdjj/f1607e9e-27ad-42a8-a2a0-96c4b5dda312"}, {"name": "deploy_resource_name", "description": "Name of this deployment resource in the stack", "type": "String", "value": "TripleOSoftwareDeployment"}, {"name": "deploy_signal_transport", "description": "How the server should signal to heat with the deployment output values.", "type": "String", "value": "NO_SIGNAL"}], "name": "deployment_resource", "options": {}, "outputs": null}]